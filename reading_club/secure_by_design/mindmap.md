# 状態の完全性の保証
## 状態の変化
### エンティティを使った状態管理
- 中心の関心事
	- ==状態の変化== に伴いシステムの ==振る舞いがどう変わるか==
  	- 空港の荷物管理システム（例）
  	- 状態の変化を把握、全ての変化に対して適切なルールが適用されることを保証（==must==）
- ==状態の変化をDDDのエンティティとしてモデリングすること(良き)==
  - 例）[エンティティ](./imgs/エンティティ.png) = 荷物
    - 同じ荷物でありながら、異なった状態を持つ
    - 受け取り済み、検査済み、荷下ろし済み、
- 状態の変化を扱うのは==エンティティ==が==最適==
- 状態の変化を扱うための方法
  - Cookieで状態管理
  - SQL、ストアド・プロシージャ
    - DBの状態を直接操作
  - UIからAPI叩いて状態変更させたり
  - でもそれぞれのアプローチをごちゃ混ぜにするのはNG（一貫性がない）
  - ==状態変化→エンティティが扱うようモデリング==する（効果的）
    - メリット： ==状態についての理解== ==その状態がどのように変わるのか==　を ==同じ場所で収集== できる  
### 正しい状態で生成されるエンティティ(正しい状態でエンティティを作成する方法)
- ==エンティティが正しい状態になっていることを保証する仕組み==←重要
- 全てのエンティティが==生成された時から==正しい状態となるように設計することが最善
#### 引数なしのコンストラクタの==危険性==
- 最もシンプル：利用価値なし
- 完全に正し状態になっていることは滅多にない
- 例）Carオブジェクト生成でデフォ値が割り当てられるアイデンティティがないオブジェクトが作られる
- よく見られる実装
  - 1. 引数なしコンストラクタ呼ぶ
  - 2. ルールを満たすように必要なSetterメソッドを呼び出していく
  - ↑忘れる。正しい状態になっていないエンティティが使われてしまう
- 引数なしのコンストラクタを要求するO/Rマッパー
  - チュートリアルだと引数なしでやってるからそのようにやるべきと思い込む←誤り
	- ==ドメインモデル== を ==永続層モデル==から==分離==すれば良い
  - 例）[data-mapper](./example_code/data_mapper.ts)
  - 例）[active_record](./example_code/active_record.rb)
#### 全ての必須の情報をコンストラクタの引数とする
- 簡単
- 例）[必須情報を全て受け取れるクラス](./example_code/car.ts)
-  必須情報をコンストラクタの引数として、任意の情報はSetterメソッドにてセットする
    - コンストラクタ内でnullチェックする
#### フルーエント・インターフェース（流れるようなインターフェース）
- 理解すれば、ビルダー・パターンとその使い所がわかる
- ==コードを自然言語(英語)で書いたテキストのように読めるようにする==
- メソッドに自身の参照を返して、メソッドを繋げられるようにする
- いくつかのトレード・オフ
  - コマンド・クエリ分離の原則違反
    - メソッドはコマンドか、クエリかのどちらかでなければならない
    - コマンド
      - 状態変更(戻り値なし)
    - クエリ
      - 状態取得(副作用なし)
- ==任意のフィールドに1つずつ値を設定したい場合に効果を発揮する==
- オブジェクトは値が追加されるたびに正しい状態を保証しなければならない。
  - フルーエント・インターフェースだけだと複数跨る制約があると対応できない
    - クラスが〇〇、△△のどちらかを一方を持たせる かつ 両方持ったらだめの場合はむずい
    - ↑==ビルダー・パターンを組み合わせる==
#### 複雑な制約
- 複数フィールドにまたがって課される制約
  - ex）あるフィールドに値が設定されると、それに応じて他フィールドに設定できる値が制限される場合
    - テスラを設定すると、自動的に電気自動車にする
    - 電気自動車を設定するとエンジンサイズなし、AWD推奨
  - ==不変条件==(常にその制約を守るようにする)の形式を取るのが一般的
    - 不変条件を確認するメソッドを追加
      - publicメソッドの処理の終わりに呼ぶ
      - 外部から呼ばれる必要はない
    - メソッドを処理している間にそのオブジェクトの不変条件は満たされない場合が出てくる場合がある
      - メソッドの終わりに不変条件の確認をすれば不変条件を満たせる
  - これでも十分に対応できないことは常にある
#### ビルダー・パターン
- 必須の情報をコンストラクタの引数にする際、引数増えたら大変
- ↑複雑
- その場合に==ビルダー・パターン==を用いる
- ここまでの方法では、制約が複数の任意項目に及ぶ場合、十分に対応できない。
- クラスが〇〇、△△のどちらかを一方を持たせる かつ 両方持ったらだめの場合
  - ↑の制約を満たす手順を踏んでオブジェクトを作成するが、==作成が完了するまで== そのオブジェクトを==外部にアクセスさせない==
  - ↑ビルダー・パターン
- 基本的な考え方
  - エンティティの生成における複雑さを==別オブジェクト（ビルダー）==の中に隠す
  - [概念図](https://claude.ai/public/artifacts/58c85180-c0de-485c-943f-d02eea9472b9)
  - 例）車をビルドするクラスがあり、その車ビルドクラスで車を設定し、build()で完成したオブジェクトを渡す
  - フルーエント・インターフェースを用いるとなお洗礼される
  - 実装方法が悩ましい
    - ビルダーは呼び出し元に対象のオブジェクトを未完成のまま渡せない
    - 内部クラスに実装する
      - プライベートのCarクラス、プライベートのCarBuiderクラスを作成
      - CarBuilderのbuildメソッドからのみオブジェクトを取得できる
- ちょっとまとめ
  - ==複雑なオブジェクトの生成の場合はビルダー・パターン==
  - ==単純な場合はコンストラクタで一気にオブジェクトを作成==
- 様々なコンストラクタによる制御
  - コンストラクタの引数で必須、任意に限らず全て受け取る
    - optionalを考慮するようになり混乱を招く
  - 全て有効な引数の組み合わせ分コンストラクタを作る
    - 大量の組み合わせがあると詰む
#### O/Rマッパーのフレームワークと複雑な制約
- 複雑なエンティティを扱う場合、どのようにDBと関連づける？
  - JPA, HibernateなどのO/Rマッパーを使う場合、ドメインオブジェクトを直接DBと関連づける←よくある
    - 小規模or一人での個人開発などではまあOK
    - ドメインが複雑、DBに触れる人数増加だと↑は難しい
- ==データベースを別システムとして見て、読み込む際に妥当性を確認することを推奨==
  - 制約が複雑になるとDBからデータを読み込んだあと、全ての不変条件が満たされることを保証する
    - データを読み込んだ後、不変条件checkのメソッドを呼び出す
#### いつ、どのオブジェクトの作成方法を使う？
- いつ、どれ？
  -  1. 全ての必須項目を持ったコンストラクタ
  -  2. フルーエント・インターフェース
  -  3. ビルダー・パターン
- これらの共通目標
  - ==作成されるオブジェクトは全てビジネス・ルールを満たしていることを保証する==  
- ビルダー・パターンはビルダーをなん度も設定を行うメソッドを呼び出すことでオブジェクトを構築する
  - ビルダーの生存期間は短くなるように設計するのが良い
    - 生存期間： ビルダーオブジェクトがメモリ上に存在し、使用可能である時間の長さ
    - ビルダーの生存期間は、使われる状況によって変わる
      - しかし
        - Webベースのシステムであれば、オブジェクトの生成は1つのリクエストの中で
        - クライアント・サーバー間の一度の往復の中で終えさせるのが良い
        - 複雑に過ぎる場合は、初期化自体をエンティティ内で管理される状態とするのが良い
### エンティティの完全性（Integrity）(エンティティの正しい状態をそのまま維持する方法)
#### エンティティをオブジェクトとして設計する際に重要なこと
  - ==状態を変えてしまうようなビジネス・ロジックを外部に出さないこと==
    - エンティティ内のデータがエンティティの外に出て、そのデータがビジネスルールに従わずに変更されてしまう
    - ↑を防ぐことが==完全性==の保護と呼ぶ
#### エンティティの完全性を保護できていない設計
##### Getter/Setterメソッドへの対応
- setterをpublicにする
  - データ・フィールドをprivateにしても、外部でフィールドを自由に変更できてしまう
  - 頑丈なドアをつけているくせにドアの鍵を閉めていないのと同じ
- 好きな値を設定できるsetメソッドを取り除き、==一方向の変更しかできないメソッドを用意する==(setPaidではなくmarkPaidのように)
- カプセル化 = ==データの解釈および、ルールをそのデータと共に囲い込んで保護すること==
##### 可変オブジェクトが共有されることへの対策
- 
##### コレクションに対する完全性の保護



